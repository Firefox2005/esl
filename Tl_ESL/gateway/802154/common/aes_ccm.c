#include "aes_ccm.h"

/*********************************************************************
 * @fn      aes_ccmAuthTran
 *
 * @brief   calc the aes ccm value 
 *
 * @param   micLen - mic lenth (should be 4)
 *
 * @param   iv - initial vector (should be 13 bytes nonce)
 *
 * @param   mStr - plaint text 
 *
 * @param   mStrLen - plaint text length
 *
 * @param   aStr -  a string  (should be AAD the data channel PDU header's first octet with NESN, SN and MD bits masked to 0)
 *
 * @param   aStrLen - a atring lenth (should be 1)
 *
 * @param   result - result (result)
 *
 * @return  status l2cap_sts_t
 */
unsigned char aes_ccmAuthTran(unsigned char micLen, unsigned char *key, unsigned char *iv, unsigned char *mStr, unsigned short mStrLen, unsigned char *aStr, unsigned char aStrLen, unsigned char *result)
{
    unsigned short msgLen;
    unsigned char mStrIndex = 0;
    ccm_flags_t flags;
    unsigned short i,j;

    aes_enc_t *tmpPtr, encTmp;
    tmpPtr = &encTmp;
    memset(tmpPtr, 0, sizeof(aes_enc_t));

    /* get B0 */
    flags.bf.L = 1;  /* L-1 (15-nonceLen-1)*/
    flags.bf.M = (micLen - 2) >> 1;
    flags.bf.aData = (aStrLen > 0) ? 1 : 0;
    flags.bf.reserved = 0;
    
    tmpPtr->bf.B[0] = flags.val;
    /* copy nonce N */
    memcpy(tmpPtr->bf.B + 1, iv, 13);
    /* last byte is mStrlen */
    tmpPtr->bf.B[14] = mStrLen >> 8;
    tmpPtr->bf.B[15] = mStrLen & 0xff;

    tmpPtr->newAstr[0] = aStrLen >> 8;
    tmpPtr->newAstr[1] = aStrLen & 0xff;
    memcpy(tmpPtr->newAstr + 2, aStr, aStrLen);
    aStrLen += 2;

    /* X0 is zero */
    memset(tmpPtr->tmpResult, 0, AES_BLOCK_SIZE);

    msgLen = aStrLen;
    /* adjust msgLen according to aStrLen and mStrLen, should be 16x */
    if (aStrLen & 0x0f) {
        msgLen &= ~0x0F;
        msgLen += 0x10;
    }

    msgLen += mStrLen;
    if (mStrLen & 0x0f) {
        msgLen &= ~0x0F;
        msgLen += 0x10;
    }
    
    /* now the msgLen should be the length of AuthData, which is generated by AddAuthData (astring, padded by 0) || PlaintexeData (mString, padded by 0)*/
    for (i = 0; i < (msgLen + AES_BLOCK_SIZE); i += AES_BLOCK_SIZE) {
        for (j = 0; j < AES_BLOCK_SIZE; j++) {
            /* get Xi XOR Bi */
            tmpPtr->tmpResult[j] ^= tmpPtr->bf.B[j];
        }

        /* use aes to get E(key, Xi XOR Bi) */
        AES_Encrypt(key, tmpPtr->tmpResult, tmpPtr->tmpResult);
        /* update B */
        if (aStrLen >= AES_BLOCK_SIZE) {
            memcpy(tmpPtr->bf.B, tmpPtr->newAstr + i, AES_BLOCK_SIZE);
            aStrLen -= AES_BLOCK_SIZE;
        } 
        else if ((aStrLen > 0) && (aStrLen < AES_BLOCK_SIZE)) {
            memcpy(tmpPtr->bf.B, tmpPtr->newAstr + i, aStrLen);
            memset(tmpPtr->bf.B + aStrLen, 0, AES_BLOCK_SIZE - aStrLen);
            aStrLen = 0;
            /* reset the mstring index */
            mStrIndex = 0;
        } 
        else if ( mStrLen >= AES_BLOCK_SIZE ) {
            memcpy(tmpPtr->bf.B, mStr + (mStrIndex*AES_BLOCK_SIZE), AES_BLOCK_SIZE);
            mStrIndex++;
            mStrLen -= AES_BLOCK_SIZE;
        } 
        else {
            memcpy(tmpPtr->bf.B, mStr + (mStrIndex*AES_BLOCK_SIZE), mStrLen);
            memset(tmpPtr->bf.B + mStrLen, 0, AES_BLOCK_SIZE - mStrLen);
        }
    }
    memcpy(result, tmpPtr->tmpResult, micLen);

    return 0;
}

/*********************************************************************
 * @fn      aes_ccmBaseTran
 *
 * @brief   calc the aes ccm value 
 *
 * @param   micLen - mic lenth (should be 4)
 *
 * @param   iv - initial vector (should be 13 bytes nonce)
 *
 * @param   mStr - plaint text 
 *
 * @param   mStrLen - plaint text length
 *
 * @param   aStr -  a string  (should be AAD the data channel PDU header's first octet with NESN, SN and MD bits masked to 0)
 *
 * @param   aStrLen - a atring lenth (should be 1)
 *
 * @param   result - result (result)
 *
 * @return  status l2cap_sts_t
 */
unsigned char aes_ccmBaseTran(unsigned char micLen, unsigned char *key, unsigned char *iv, unsigned char *mStr, unsigned short mStrLen, unsigned char *aStr, unsigned char aStrLen, unsigned char *mic, unsigned char opt)
{
    ccm_flags_t flags;
    unsigned char msgLen;
    unsigned short i;
    unsigned char j;
    unsigned short counter = 1;

    aes_enc_t *tmpPtr, encTmp;
    tmpPtr = &encTmp;
    memset(tmpPtr, 0, sizeof(aes_enc_t));
    
    memset(&flags, 0, sizeof(ccm_flags_t));
    flags.bf.L = 1;
    tmpPtr->bf.A[0] = flags.val;

    /* set the iv */
    memcpy(tmpPtr->bf.A+1, iv, 13);

    tmpPtr->bf.A[14] = tmpPtr->bf.A[15] = 0;

    /*get the S0(S0:= E(Key, A0),see IEEE 802.15.4-2006 p. 234)*/
    AES_Encrypt(key, tmpPtr->bf.A, tmpPtr->tmpResult);
    
    /*Encrypted authentication tag U = (Unencrypted authentication tag T) XOR (the leftmost micLen octets of S0)*/
    for (i = 0; i < micLen; i++) {
        mic[i] ^= tmpPtr->tmpResult[i];
    }

    tmpPtr->bf.A[14] = counter >> 8;
    tmpPtr->bf.A[15] = counter & 0xff;
    if (opt == AES_DECRYPTION) {
        msgLen = mStrLen - micLen;
    }

    msgLen = mStrLen;
    if (msgLen & 0x0f) {
        msgLen &= ~0x0F;
        msgLen += 0x10;
    }

    for (i = 0; i < msgLen; i += AES_BLOCK_SIZE) {
        /* use aes to the E(key, Ai) */
        AES_Encrypt(key, tmpPtr->bf.A, tmpPtr->tmpResult);

        for (j = 0; (j < AES_BLOCK_SIZE) && (i+j < mStrLen); j++) {
            mStr[i+j] ^= tmpPtr->tmpResult[j];
        }

        /* update Ai */
        counter++;
        tmpPtr->bf.A[14] = counter >> 8;
        tmpPtr->bf.A[15] = counter & 0xff;
    }
    return 0;
}


unsigned char aes_ccmEncTran(unsigned char micLen, unsigned char *key, unsigned char *iv, unsigned char *mStr, unsigned short mStrLen, unsigned char *aStr, unsigned char aStrLen, unsigned char *mic)
{
	return aes_ccmBaseTran(micLen, key, iv, mStr, mStrLen, aStr, aStrLen, mic, AES_ENCRYPTION);
}

unsigned char aes_ccmDecTran(unsigned char micLen, unsigned char *key, unsigned char *iv, unsigned char *mStr, unsigned short mStrLen, unsigned char *aStr, unsigned char aStrLen, unsigned char *mic)
{
    return aes_ccmBaseTran(micLen, key, iv, mStr, mStrLen, aStr, aStrLen, mic, AES_DECRYPTION);
}

unsigned char aes_ccmDecAuthTran(unsigned char micLen, unsigned char *key, unsigned char *iv, unsigned char *mStr, unsigned short mStrLen, unsigned char *aStr, unsigned char aStrLen, unsigned char *mic)
{
    unsigned char tmpMic[AES_BLOCK_SIZE];
    unsigned char i;
    aes_ccmAuthTran(micLen, key, iv, mStr, mStrLen, aStr, aStrLen, tmpMic);
    for (i = 0; i < micLen; i++) {
        if (mic[i] != tmpMic[i]) {
            return -1;
        }
    }
    return 0;
}
